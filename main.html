<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Water Ripple with iframe and URL blocking</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #121629;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
    }
    #rippleCanvas {
      display: block;
      background: linear-gradient(135deg, #1f233d, #121629);
      border-radius: 24px;
      max-width: 720px;
      width: 90vw;
      height: 90vh;
      cursor: pointer;
      box-shadow: 0 0 30px rgba(138, 120, 255, 0.5);
    }
    #themeToggle {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 56px;
      height: 56px;
      background: rgba(255 255 255 / 0.1);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      transition: background-color 0.5s ease;
      z-index: 10;
    }
    #themeToggle:hover {
      background: rgba(255 255 255 / 0.2);
    }
    #themeToggle svg {
      width: 28px;
      height: 28px;
      fill: #8a78ff;
      transition: fill 0.6s ease;
    }
    body.light-theme #themeToggle svg {
      fill: #5a4edd;
      filter: drop-shadow(0 0 1px rgba(138,120,255,0.8));
    }
  </style>
</head>
<body>

  <canvas id="rippleCanvas" aria-label="Water ripple simulation" role="img"></canvas>

  <button id="themeToggle" aria-label="Toggle light/dark mode" title="Toggle light/dark mode">
    <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg">
      <circle cx="12" cy="12" r="5"/>
      <g stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <line x1="12" y1="1" x2="12" y2="3"/>
        <line x1="12" y1="21" x2="12" y2="23"/>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
        <line x1="1" y1="12" x2="3" y2="12"/>
        <line x1="21" y1="12" x2="23" y2="12"/>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
      </g>
    </svg>
  </button>

  <script>
    // === Fast Iframe blocking ===
    if (window.self !== window.top) {
      // If loaded inside iframe, redirect or block immediately
      document.body.innerHTML = "<h1 style='color:red; text-align:center; margin-top: 40vh;'>Access Denied: iframe embedding is blocked.</h1>";
      throw new Error("Iframe embedding blocked");
    }

    // === Fast URL access blocking ===
    // Only allow if referrer is from your own domain (example.com) or blank (allow direct if you want)
    // Change 'yourdomain.com' to your actual domain name!
    const allowedDomain = "the-grand-project.vercel.app";

    if (document.referrer) {
      try {
        const refDomain = new URL(document.referrer).hostname;
        if (!refDomain.includes(allowedDomain)) {
          // Referrer is from a domain NOT allowed, block access immediately
          document.body.innerHTML = "<h1 style='color:red; text-align:center; margin-top: 40vh;'>Access Denied: Unauthorized access.</h1>";
          throw new Error("Unauthorized referrer blocked");
        }
      } catch {
        // Malformed referrer? Block anyway
        document.body.innerHTML = "<h1 style='color:red; text-align:center; margin-top: 40vh;'>Access Denied: Unauthorized access.</h1>";
        throw new Error("Malformed referrer blocked");
      }
    } else {
      // No referrer - usually direct access or via bookmarks
      // Uncomment below if you want to block direct URL typing as well:
      /*
      document.body.innerHTML = "<h1 style='color:red; text-align:center; margin-top: 40vh;'>Access Denied: Direct access blocked.</h1>";
      throw new Error("Direct URL access blocked");
      */
    }

    // === Ripple canvas setup ===

    const canvas = document.getElementById('rippleCanvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let gridWidth, gridHeight;
    const gridSpacing = 8;

    let previous = [];
    let current = [];
    const damping = 0.98;

    function setup() {
      width = canvas.clientWidth;
      height = canvas.clientHeight;

      canvas.width = width;
      canvas.height = height;

      gridWidth = Math.floor(width / gridSpacing);
      gridHeight = Math.floor(height / gridSpacing);

      previous = new Array(gridWidth * gridHeight).fill(0);
      current = new Array(gridWidth * gridHeight).fill(0);
    }

    setup();

    window.addEventListener('resize', () => {
      setup();
    });

    function idx(x, y) {
      return y * gridWidth + x;
    }

    function updateWave() {
      for(let y=1; y < gridHeight -1; y++) {
        for(let x=1; x < gridWidth -1; x++) {
          const i = idx(x,y);
          current[i] = (
            (previous[idx(x-1,y)] +
             previous[idx(x+1,y)] +
             previous[idx(x,y-1)] +
             previous[idx(x,y+1)]) / 2
          ) - current[i];

          current[i] *= damping;
        }
      }
      [previous, current] = [current, previous];
    }

    function drawWave() {
      ctx.clearRect(0, 0, width, height);

      for(let y=0; y < gridHeight; y++) {
        for(let x=0; x < gridWidth; x++) {
          const i = idx(x,y);
          const val = previous[i];

          const brightness = Math.min(Math.max(100 + val * 500, 0), 255);

          ctx.fillStyle = `rgb(20, ${brightness}, ${brightness + 50})`;
          ctx.fillRect(x * gridSpacing, y * gridSpacing, gridSpacing, gridSpacing);
        }
      }
    }

    function animate() {
      updateWave();
      drawWave();
      requestAnimationFrame(animate);
    }

    animate();

    function disturb(x, y, radius = 3, strength = 1) {
      const gx = Math.floor(x / gridSpacing);
      const gy = Math.floor(y / gridSpacing);

      for(let dy = -radius; dy <= radius; dy++) {
        for(let dx = -radius; dx <= radius; dx++) {
          const nx = gx + dx;
          const ny = gy + dy;
          if(nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
            const i = idx(nx, ny);
            previous[i] += strength;
          }
        }
      }
    }

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      disturb(mx, my, 2, 1);
    });

    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      disturb(mx, my, 3, 3);
    });

    // Theme toggle button
    const themeToggle = document.getElementById('themeToggle');
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('light-theme');
    });
  </script>

</body>
</html>
